可重入锁(ReentrantLock)应用范围是挺广的，可是一直没好好研究下实现。今天撸一把可重用锁。
##### 什么是可重入？
一个线程可多次取得锁，称为可重入。

##### 怎么用？
ReentrantLock.lock()
ReentrantLock.unlock();
就是这么简单！！

##### 怎么实现原理是什么？
ReentrantLock.java一个内部抽象类Sync.java，继承AbstractQueuedSynchronizer, Sync.java有两个实现类UnfairSync.java，FairSync.java。




Java未开源的Unsafe类
Unsafe类可以为我们提供高效并且线程安全方式操作变量，直接和内存数据打交道。

获取Unsafe实体的方法

复制代码
    private static Unsafe getUnsafeInstance() throws SecurityException,
        NoSuchFieldException, IllegalArgumentException,
        IllegalAccessException {
        Field theUnsafeInstance = Unsafe.class.getDeclaredField("theUnsafe");
        theUnsafeInstance.setAccessible(true);
        return (Unsafe) theUnsafeInstance.get(Unsafe.class);
    }
复制代码
 

该方法可以获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。

long objectOffset = unsafe.objectFieldOffset(User.class.getDeclaredField("value"));
        Object value = unsafe.getObject(new User(), objectOffset);
//获取静态字段的偏移量
unsafe.staticFieldOffset(User.class.getDeclaredField("value"));
 

常用方法一: compareAndSwapInt(线程安全的)

复制代码
/** 
* 比较obj的offset处内存位置中的值和期望的值，如果相同则更新。此更新是不可中断的。 
*  
* @param obj 需要更新的对象 
* @param offset obj中整型field的偏移量 
* @param expect 希望field中存在的值 
* @param update 如果期望值expect与field的当前值相同，设置filed的值为这个新值 
* @return 如果field的值被更改返回true 
*/  
public native boolean compareAndSwapInt(Object obj, long offset, int expect, int update); 
复制代码
 

常用方法二:  compareAndSwapObject 和上面方法功能一样，只不过是设置Object类型的变量

public native boolean compareAndSwapObject(Object obj, long offset, Object expect, Object update);
 

常用方法三： putOrderedInt 设置值 并且马上写入主存，该变量必须是volatile类型

复制代码
/** 
* 设置 volatile 类型到int值
*  
* @param obj 需要更新的对象 
* @param offset obj中整型field的偏移量 
* @param expect 希望field中存在的值 
*/
void sun.misc.Unsafe.putOrderedInt(Object obj, long offset, int expect)
