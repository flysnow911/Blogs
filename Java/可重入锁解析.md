可重入锁(ReentrantLock)应用范围是挺广的，可是一直没好好研究下实现。今天撸一把可重用锁。
##### 什么是可重入？
一个线程可多次取得锁，称为可重入。

##### 怎么用？
ReentrantLock.lock()
ReentrantLock.unlock();
就是这么简单！！

##### 怎么实现原理是什么？
ReentrantLock.java一个内部抽象类Sync.java，继承AbstractQueuedSynchronizer, Sync.java有两个实现类UnfairSync.java，FairSync.java。
搞懂核心方法lock的实现，就懂了ReentrantLock.java的原理。
lock的核心是tryAcquire(int acquires)方法，先看非公平的锁的实现。

`final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    //1. 如果该锁未被任何线程占有，该锁能被当前线程获取
	if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
	//2.若被占有，检查占有线程是否是当前线程
    else if (current == getExclusiveOwnerThread()) {
		// 3. 再次获取，计数加一
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
	}`
代码逻辑很简单：
1. 如果该锁未被任何线程占有，该锁能被当前线程获取
2.若被占有，检查占有线程是否是当前线程
3.如果是，则计数+1，重入。否则退出，获取锁失败。
以上代码有两个核心处：
`int c = getState();`
`compareAndSetState(0, acquires)`

getState()方法实现：

`/**
*Returns the current value of synchronization state.
*This operation has memory sematics of a {@code volitile} read.
*/
protected final int getState(){
	return state;
 }`

`/**
 * The synchronization state.
 */
private volatile int state;`

从以上注释可以看出，state是volatile修饰的，所以能保证每个线程拿到该值都是最新的。所以用state来标志锁是否被占用。

再看compareAndSetState(0, acquires)的实现：
`/**
*Atomically sets synchronization state to the given updated value if the current 
*state value equals the expected value.
* This operation has memory sematics of a read.
*/
 protected final boolean compareAndSetState(int expect, int update){
	return unsafe.compareAndwapInt(this, stateOffset , expeted, update);
 } `
从以上注释可以看出，该方法作用：如果state的值与参数expected值相等，那么就把state值设置成参数update，并且它是线程安全的。

到这里，就把原理说清楚了。
Unsafe没有开源， unsafe.compareAndwapInt(this, stateOffset , expeted, update);方法私库直接操作内存，高效且线程安全地操作变量。

##### Fair和UnFair有啥不同？
公平锁：取锁之前判断不光判断是否空闲，还要判断是否有前置节点，如果有，即使锁没有被占用，也不能获取锁。
不公平锁：直接取锁，空闲则取到。

##### AbstractQueuedSynchronizer
这个抽象类中是Sync的父类，是FairSync和UnFairSync的祖父，他维护了链表，用于公平锁。





Java未开源的Unsafe类
Unsafe类可以为我们提供高效并且线程安全方式操作变量，直接和内存数据打交道。

获取Unsafe实体的方法

复制代码
    private static Unsafe getUnsafeInstance() throws SecurityException,
        NoSuchFieldException, IllegalArgumentException,
        IllegalAccessException {
        Field theUnsafeInstance = Unsafe.class.getDeclaredField("theUnsafe");
        theUnsafeInstance.setAccessible(true);
        return (Unsafe) theUnsafeInstance.get(Unsafe.class);
    }
复制代码
 

该方法可以获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。

long objectOffset = unsafe.objectFieldOffset(User.class.getDeclaredField("value"));
        Object value = unsafe.getObject(new User(), objectOffset);
//获取静态字段的偏移量
unsafe.staticFieldOffset(User.class.getDeclaredField("value"));
 

常用方法一: compareAndSwapInt(线程安全的)

复制代码
/** 
* 比较obj的offset处内存位置中的值和期望的值，如果相同则更新。此更新是不可中断的。 
*  
* @param obj 需要更新的对象 
* @param offset obj中整型field的偏移量 
* @param expect 希望field中存在的值 
* @param update 如果期望值expect与field的当前值相同，设置filed的值为这个新值 
* @return 如果field的值被更改返回true 
*/  
public native boolean compareAndSwapInt(Object obj, long offset, int expect, int update); 
复制代码
 

常用方法二:  compareAndSwapObject 和上面方法功能一样，只不过是设置Object类型的变量

public native boolean compareAndSwapObject(Object obj, long offset, Object expect, Object update);
 

常用方法三： putOrderedInt 设置值 并且马上写入主存，该变量必须是volatile类型

复制代码
/** 
* 设置 volatile 类型到int值
*  
* @param obj 需要更新的对象 
* @param offset obj中整型field的偏移量 
* @param expect 希望field中存在的值 
*/
void sun.misc.Unsafe.putOrderedInt(Object obj, long offset, int expect)
