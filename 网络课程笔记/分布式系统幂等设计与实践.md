# 幂等
### 请求层面上幂等
保证请求多次重复执行和执行一次的结果相同。

### 业务层面上的幂等
- 同一用户不重复下单
- 商品不超卖
- MQ消息端去重

### 冪等的目的
  请求可能被**重试**或**重放**

### 冪等
结果灾难

### 幂等范围
**读&写请求**
读请求：不改变数据，不需要幂等
写请求：改变数据 -> 需要幂等

### 架构层面架构层面
** 哪些请求对数据造成改变？
		APP  -> NO
		反向代理层 ？ -> NO
		网关层？ -> NO
		业务逻辑层？ -> NO
		数据访问层？ -> YES
		
### CRUD
	ps：不要用自增id，要用业务主键。自增主键暴露商业机密。
	
## 业务层幂等
由于冗余部署多个进程 -> 存在并发消费的可能性
**策略：并发转变成串行消费**

**问题的本质**
分布式锁问题

## 分布式锁
请求处理串行化 ->  实际表现为互斥锁

## 分布式锁目的
- 防止重复下单
- 解决业务层幂等  
- MQ消息消费幂等

## 分布式锁
###### 基于Redis
	原理：Redis单线程串行处理

实现方式：setNx
###### 存在问题
1.  单点问题
2.  主从方式，数据异步，锁失效
3.  锁续期问题
ps: 2,3是最主要的问题。
 
## 高可用分布式锁设计目标
**设计目标**
1. 强一致性
2. 高可用，
3. 锁要自动续期，及自动释放
4. 代码高度抽象，业务接入极简
5. 可视化管理 监控

### 分布式锁存储选型
#### etcd
-   简单kv
-   强一致性
-   高可用
-   无单点
-   数据高可靠
-   持久化
-   分布式锁整体方案
- 	client TTL模式

**流程：**
1. 业务方申请资源锁，调用时提供key ,ttl。
2. etcd生成uuid, 作为当前锁的唯一凭证，将（key ,uuid, ttl）写入etcd
3. 检查etcd中此key是否存在，如没有，尝试写入key,写入失败，拿锁失败，写入成功拿到锁
4. 拿到锁后，心跳线程启动，心跳线程的维持时间为ttl/3, compare and swap uuid,从而将key值续租
*详细参考相关etcd api

获取锁平均耗时监控
平时耗时2.1ms
强一致性，根据raft协议， 时间稍长。

### 兼容性测试
集群管理模式
以三个节点为例 
-  单点停机，不影响写读，结果一致性
-  只有一个节点，读会停机，写入正常
-  理论上只要不是多节点同时停机，线上服务不影响


 etcd恢复 版本
 etcd自有数据恢复方式
  如果服务停机，所有数据转移重启
  etcd的增删，节点迁移等，部署相关，均有相关操作。
 
 
 
 


