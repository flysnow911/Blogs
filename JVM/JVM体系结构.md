看图说话，上中下，部分描述整个结构。
上：类加载器。
中：可以从线程独有，线程共有。
     线程独有：栈，本地方法栈（native方法），程序计数器
	 共用：方法区，堆。
下：执行器，本地方法接口 本地方法库

类加载器
将.class加载到内存的方法区。

类加载器的分类：
虚拟机自带的
	启动类加载器
	扩展类加载器
	应用程序加载器
	
用户自定义
    继承java.lang.classloader，用户实现自定义加载器。

沙箱安全机制
    严格限制jvm内部访问系统资源，做到资源的有效隔离。资源包括：cpu，硬盘，网络等。
	
双亲委派机制
    每个类的加载都交由父加载器执行，如果父加载器不能加载该类，再由子类加载。
	
程序计数器
	即指针，指向下一条要执行的指令。指令存在java栈中。

本地方法栈 本地方法接口 本地方法库
    如果java程序调用native方法，那么本地方法栈中有一条调用指令，调用本地方法接口，而本地方法库提供本地方法的具体实现。

方法区
    所有线程共享。包含以下几类：
	静态变量 常量  类信息 运行时常量。

三种jvm
 sun hotspot
 bea jrockit
 ibm j9 vm

堆
  逻辑上分三部分：
  新生代： 伊甸 s1 s2 。8:1:1。 minor gc。
  老年代: 默认15次gc，进入。养老快满了，就full gc。
  永久代

  物理上分， 只包含新生代，老年代。 永久代在方法区。

OOM的原因：
1.xms xmx不够。
2.创建大量对象，没有及时回收。

永久代：
永久代是一个常驻内存区域，用于存放jdk自身携带的Class, Interface元数据。不会被垃圾回收掉。
jvm关闭，内存才会释放。
OutOfMemoeryError:PermGen space。如果出现这种情况，是因为程序启动时，加载了太多的第三方jar包。
Jdk1.6：      有永久代，常量池在方法区。
jdk1.7:       有永久代，但在“去永久代”， 常量池在堆。
jdk1.8及之后：无永久代，常量池在元空间。--> why?  https://juejin.im/post/6844904020964802574


内存调优
   即堆参数调优。
   xms（1/64） xmx(1/4)。
   printGCDetails
   
GC
  次数上频繁收集young区。
  次数上较少收集Old区。
  基本不动Perm区。
     
GC4大算法：
引用计数法
复制算法
标记清除
标记压缩
标记清除压缩

分代收集算法：
   没有最好的算法，只有最合适的算法。依据不同情况决算法。
年轻代 
    对象存货率低，占用空间小 --->  复制算法，速度快，无内存碎片。

老年代：
    空间大，存活率高 ---> 标记清除，标记压缩（内存碎片）混合使用。
	
hotspot采用cms回收器， mark-sweep回收内存，碎片问题，用mark-compact的回收器
做为补偿，当内存回收率不理想，

运行时数据区及线程 
图

每个线程:独立包含程序计数器,栈,本地方法栈。
线程共享:堆, 元空间。

pc寄存器：
存储一个线程下一条需要执行的指令地址。由执行引擎读取下一条指令。






	
	


	





